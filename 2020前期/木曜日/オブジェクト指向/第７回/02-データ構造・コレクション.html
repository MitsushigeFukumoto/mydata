<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="”robots”" content="”noindex,nofollow,noarchive”">
  <meta name="generator" content="pandoc">
  <title>データ構造・コレクション</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<style type="text/css">
*,
*::before,
*::after {
  box-sizing: border-box;
}

code {
  white-space: pre-wrap;
}

span.smallcaps {
  font-variant: small-caps;
}

span.underline {
  text-decoration: underline;
}

div.column {
  display: inline-block;
  vertical-align: top;
  width: 50%;
}

body {
  font-size: 14pt;
  font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", YuGothic, "ヒラギノ角ゴ ProN W3", Hiragino Kaku Gothic ProN,
    Arial, "メイリオ", Meiryo, sans-serif;
  max-width: 1024px;
  margin: 0 auto;
  padding: 2em;
  background-color: #f8f8f8;
  color: #232323;
}

hr {
  height: 4px;
  padding: 0;
  margin: 6rem 0;
  background-color: #e7e7e7;
  border: 0 none;
  background:
    url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC");
}

p,
table {
  font-family: "游明朝", YuMincho, "ヒラギノ明朝 ProN W3", "Hiragino Mincho ProN", "HG明朝E", "ＭＳ Ｐ明朝", "ＭＳ 明朝", serif;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  line-height: 2rem;
  letter-spacing: 0.03rem;
}

strong {
  text-decoration: none;
  color: hsla(0, 75%, 55%, 1);
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: normal;
  color: #232323;
  letter-spacing: 0.05rem;
  margin-top: 2rem;
}

h1 {
  font-size: 2rem;
  margin: 2rem auto 1rem;
  text-align: center;
}

h2 {
  font-size: 1.75rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  margin: 2rem 0 1rem;
}

h3 {
  font-size: 1.5rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  margin: 2rem 0 1rem;
}

h4 {
  font-size: 1.25rem;
  margin: 2rem 0 1rem;
}

h5 {
  font-size: 1.2rem;
  margin: 2rem 0 1rem;
}

h6 {
  font-size: 1.1rem;
  margin: 2rem 0 1rem;
}

ul,
ol {
  font-family: "游明朝", YuMincho, "ヒラギノ明朝 ProN W3", "Hiragino Mincho ProN", "HG明朝E", "ＭＳ Ｐ明朝", "ＭＳ 明朝", serif;
  line-height: 1.6;
  letter-spacing: 0.025rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding-left: 2rem;
}

ul li,
ol li {
  padding-left: .5rem;
}

ul ul,
ol ul,
ul ol,
ol ol {
  padding-left: 1.5rem;
}

table {
  border-collapse: collapse;
  border: 1px solid rgba(0, 0, 0, 0.2);
  max-width: 100%;
  font-size: 1rem;
  overflow: auto;
}

table th {
  text-align: center;
  font-weight: nomal;
  background-color: #f0f0f0;
  color: rgba(0, 0, 0, 0.85);
  border: 1px solid rgba(0, 0, 0, 0.2);
}

table tr {
  border: 1px solid rgba(0, 0, 0, 0.2);
  padding: 2px 8px;
}

table td {
  border: 1px solid rgba(0, 0, 0, 0.2);
  padding: 2px 8px;
}

a {
  color: #5484c8;
}

.margin-clear {
  margin-left: 0;
}

blockquote {
  border-left: 4px #ddd solid;
  padding: 0;
  margin: 2rem;
}

blockquote * {
  color: #999;
}

blockquote p {
  padding: 0 1rem;
  text-indent: 0;
}

img,
iframe,
figure {
  max-width: 100%;
}

p img {
  display: block;
  max-width: 100%;
  margin: 0 auto;
}

pre,
code,
var,
samp,
kbd,
.mono {
  font-family: "Ricty Diminished", "Consolas", 'Courier New', Courier, Monaco, monospace;
  line-height: 1.2;
}

table code,
p code,
ul code,
ol code {
  display: inline-block;
  border: 1px solid #eaeaea;
  background-color: rgb(119, 119, 119);
  color: #f8f8f8;
  white-space: nowrap;
  border-radius: 2px;
  display: inline-block;
  padding-top: 6px;
  padding-left: 8px;
  padding-right: 8px;
  padding-bottom: 0px;
  margin: 0 4px;
}

pre code {
  border: 1px solid #eaeaea;
  background-color: #f5f5f5;
  border-radius: 2px;
  margin: 0;
  padding: 0;
  white-space: pre;
  font-size: 1rem;
}

.highlight pre {
  background-color: #f5f5f5;
  border: 1px solid #cccccc;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 4px;
}

div.sourceCode {
  background-color: #f5f5f5;
  border: 1px solid #cccccc;
  margin-top: 1rem;
  margin-bottom: 1rem;
  border-radius: 4px;
  padding: 1rem;
}

pre code,
pre tt {
  background-color: transparent;
  border: none;
}

table.sourceCode,
tr.sourceCode,
td.lineNumbers,
td.sourceCode {
  margin: 0;
  padding: 0;
  vertical-align: top;
  border: none;
}

table.sourceCode pre {
  padding: 2px;
  margin: 0;
  border: none;
  color: inherit;
}
table.sourceCode code {
  color: inherit;
}

table.sourceCode {
  width: 100%;
  line-height: 100%;
}

td.lineNumbers {
  text-align: right;
  color: #aaaaaa;
  border-right: 1px solid #aaaaaa;
}
</style>
</head>
<body>
  <header>
  <h1 class="title">データ構造・コレクション</h1>
        </header>
<blockquote>
<p>オブジェクト指向プログラミングおよび演習1 第7回</p>
<p>Javaでのデータを扱う方法として、コレクションを学びましょう</p>
</blockquote>
<h1 id="さまざまなデータ構造">さまざまなデータ構造</h1>
<h2 id="データ構造の種類">データ構造の種類</h2>
<p>配列は、「複数のデータを一つにまとめて扱う方法」として学んだと思います。配列を扱うことでバラバラになっていたデータをひとまとめにすることができます。<br />
Javaでは、配列の他にもデータをひとまとめにして扱うことのできる仕組みがあります。</p>
<p>データをどのようにして扱うかを「データ構造(Data Structure)」といいます。<br />
Javaで扱えるデータ構造にはたくさんの種類があり、それぞれ得手不得手があります。</p>
<p>データ構造をカテゴライズすると、大きく分けて以下の3つになります。 それぞれの特徴を解説します。<br />
特徴をよく理解した上で使用するようにしましょう。</p>
<h3 id="リストlist">リスト(List)</h3>
<ul>
<li>データを順番通りに格納する
<ul>
<li>順番は操作しない限り保証される</li>
</ul></li>
<li>データの重複を許可する</li>
</ul>
<p>今までに学んだ配列はこのリストの一種です。単純にデータを格納したい場合などに用います。</p>
<ul>
<li>インターフェイス
<ul>
<li>java.util.List （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/List.html" target="_blank">List (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
<li>代表的なリスト (Listインターフェイスを実装したクラス)
<ul>
<li>java.util.ArrayList （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/ArrayList.html" target="_blank">ArrayList (Java SE 11 &amp; JDK 11 )</a> ）</li>
<li>java.util.LinkedList （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/LinkedList.html" target="_blank">LinkedList (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
</ul>
<h3 id="セットset">セット(Set)</h3>
<ul>
<li>データの重複を許可しない</li>
<li>データの順序は不確定</li>
</ul>
<p>データの重複を避けて格納したい場合などに用います。</p>
<ul>
<li>インターフェイス
<ul>
<li>java.util.Set （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Set.html" target="_blank">Set (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
<li>代表的なセット (Setインターフェイスを実装したクラス)
<ul>
<li>java.util.HashSet （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/HashSet.html" target="_blank">HashSet (Java SE 11 &amp; JDK 11 )</a> ）</li>
<li>java.util.LinkedHashSet （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/LinkedHashSet.html" target="_blank">LinkedHashSet (Java SE 11 &amp; JDK 11 )</a> ）</li>
<li>java.util.TreeSet （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/TreeSet.html" target="_blank">TreeSet (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
</ul>
<h3 id="マップmap">マップ(Map)</h3>
<ul>
<li>キーと値でペアとしてデータを格納する
<ul>
<li>キーの重複は許可されない</li>
</ul></li>
</ul>
<p>Key-Valueでデータを保持したい場合に用います。</p>
<ul>
<li>インターフェイス
<ul>
<li>java.util.Map （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Map.html" target="_blank">Map (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
<li>代表的なマップ (Mapインターフェイスを実装したクラス)
<ul>
<li>java.util.HashMap （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/HashMap.html" target="_blank">HashMap (Java SE 11 &amp; JDK 11 )</a> ）</li>
<li>java.util.LinkedHashMap （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/LinkedHashMap.html" target="_blank">LinkedHashMap (Java SE 11 &amp; JDK 11 )</a> ）</li>
<li>java.util.TreeMap （ <a href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/TreeMap.html" target="_blank">TreeMap (Java SE 11 &amp; JDK 11 )</a> ）</li>
</ul></li>
</ul>
<h2 id="javaでのデータ構造クラス">Javaでのデータ構造クラス</h2>
<p>Javaには、これらのデータ構造をAPIとして提供しています。</p>
<p>これらのデータ構造を表すクラスたちは、<code>java.utilパッケージ</code>に属していて、List,Setインターフェイスは、さらに<code>java.util.Collection</code>を継承しています(※Mapだけ若干違います)。このインターフェイスを実装しているクラス群を総称して<code>コレクションフレームワーク(Collection Framework)</code>と呼びます。</p>
<p>また、データ構造を表すクラスのことを単に<strong><em>コレクション</em></strong>とも呼びます。</p>
<h2 id="まずは触ってみよう">まずは触ってみよう</h2>
<p>以下のソースコードは、コレクションの中でも最も単純なデータ構造のArrayListと配列で、同じ動作をするように書かれたものです。</p>
<p>適当にプロジェクトを作り、実行してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">//import java.util.List;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">//import java.util.ArrayList;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="bu">String</span>[] names = <span class="kw">new</span> <span class="bu">String</span>[<span class="dv">3</span>];</span>
<span id="cb1-6"><a href="#cb1-6"></a>names[<span class="dv">0</span>] = <span class="st">&quot;たろう&quot;</span>;</span>
<span id="cb1-7"><a href="#cb1-7"></a>names[<span class="dv">1</span>] = <span class="st">&quot;じろう&quot;</span>;</span>
<span id="cb1-8"><a href="#cb1-8"></a>names[<span class="dv">2</span>] = <span class="st">&quot;さぶろう&quot;</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">for</span> (<span class="bu">String</span> name: names) {</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(name);</span>
<span id="cb1-12"><a href="#cb1-12"></a>}</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; nameList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb1-15"><a href="#cb1-15"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;たろう&quot;</span>);</span>
<span id="cb1-16"><a href="#cb1-16"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;じろう&quot;</span>);</span>
<span id="cb1-17"><a href="#cb1-17"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;さぶろう&quot;</span>);</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="kw">for</span> (<span class="bu">String</span> name: nameList) {</span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(name);</span>
<span id="cb1-21"><a href="#cb1-21"></a>}</span></code></pre></div>
<p>書き方としては、どちらも似ています。拡張for文を使用すれば、値を取り出し画面に表示する処理は同じになっています。</p>
<h2 id="コレクションと配列の異なるところ">コレクションと配列の異なるところ</h2>
<h3 id="その1-確保するサイズを明確にしなくてもよい">その1. 確保するサイズを明確にしなくてもよい</h3>
<p>コレクションは、ソースコードを見てもらえば分かるように、コレクションの宣言時に要素の最大数を指定していません。</p>
<p>配列は要素の最大値を指定しなければ値を格納することすらできませんでしたが、コレクションは「追加する」というメソッドを呼び出せば、現在の要素数に関係なく要素を順次追加することが可能です。データを追加しようとする際に、用意したメモリ領域を超えるような場合は、自動的に領域を追加するようになっています。</p>
<h3 id="その2-不等号の括弧内で格納する型を指定する">その2. 不等号の括弧内で格納する型を指定する</h3>
<p>上記例の場合で言えば、<code>nameList</code>に格納する型は<code>String</code>です。</p>
<p>ここで指定した型のポインタを格納できる点は配列と同じですが、注意点がひとつあります。それは、指定できる型は、<strong><em>クラス型のみ</em></strong> に限られる、という点です。<br />
例えば、Heroクラスなどは格納できますが、intやdoubleでは指定することができません。</p>
<p>では、数値などの基本的なデータ型(プリミティブ型)を格納させたい場合はどうするかと言うと、intならInteger型、doubleならDouble型など、それぞれに対応したラッパークラスを型として指定してあげれば良いです。</p>
<p>プリミティブ型とその型のラッパークラスの対応表を以下にまとめました。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">基本データ型（プリミティブ型）</th>
<th style="text-align: left;">ラッパークラス</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">byte</td>
<td style="text-align: left;">Byte</td>
</tr>
<tr class="even">
<td style="text-align: left;">short</td>
<td style="text-align: left;">Short</td>
</tr>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">Integer</td>
</tr>
<tr class="even">
<td style="text-align: left;">long</td>
<td style="text-align: left;">Long</td>
</tr>
<tr class="odd">
<td style="text-align: left;">char</td>
<td style="text-align: left;">Character</td>
</tr>
<tr class="even">
<td style="text-align: left;">float</td>
<td style="text-align: left;">Float</td>
</tr>
<tr class="odd">
<td style="text-align: left;">double</td>
<td style="text-align: left;">Double</td>
</tr>
<tr class="even">
<td style="text-align: left;">boolean</td>
<td style="text-align: left;">Boolean</td>
</tr>
</tbody>
</table>
<p>プリミティブ型でコレクションを作成したい場合は、これらのラッパークラスを指定しましょう。</p>
<p>プリミティブ型とラッパークラスはJavaの中では非常に特殊な関係にあります。 ラッパークラスで宣言された変数（コレクションの要素なども含む）には、特に明記しなくても、プリミティブ型の状態で値を渡すと、自動的にラッパークラスへ型変換を行い、格納することができます。</p>
<p>この自動変換機能を、<code>Javaのオートボクシング(Auto Boxing)機能</code>と呼びます。</p>
<p>以下のソースコードを見てください。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">//import java.util.List;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">//import java.util.ArrayList;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; numList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb2-6"><a href="#cb2-6"></a>numList.<span class="fu">add</span>(<span class="dv">10</span>);</span>
<span id="cb2-7"><a href="#cb2-7"></a>numList.<span class="fu">add</span>(<span class="dv">20</span>);</span>
<span id="cb2-8"><a href="#cb2-8"></a>numList.<span class="fu">add</span>(<span class="dv">55</span>);</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">for</span> (<span class="dt">int</span> num: numList) {</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(num);</span>
<span id="cb2-12"><a href="#cb2-12"></a>}</span></code></pre></div>
<p>このソースコードをコンパイルしてみればわかりますが、エラーは出ません。Integer型の要素に、intの値を格納していますが、オートボクシング機能により、intの値は自動的にInteger型へ変換されて格納されています。</p>
<p>従って、ArrayListの内部で保持している型は、intの値を格納したとしてもInteger型のインスタンスが生成されて格納されています。</p>
<p>また、不等号の括弧で囲われた型の指定方法は、<strong><em>ジェネリクス:総称型(Generics)</em></strong> と呼び、型を厳密に指定することでプログラム実行時でなく、コンパイル時に型の不整合を検知するようになっています。 こういった仕組みを<strong><em>型安全</em></strong> と呼びます。この辺りのお話は、他のプログラミング言語とも絡んでくる話になりますので、機会があればお話させていただきます。</p>
<h4 id="古いバージョンのjavaを使用する場合の注意点">古いバージョンのJavaを使用する場合の注意点</h4>
<p>上記サンプルソースでは、ArrayListの宣言部は以下のようになっています。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; nameList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span></code></pre></div>
<p>この書き方は、Java SE 6以降での書き方です。では、それ以前はどのようにしていたかと言うと、以下のようになります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; nameList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">String</span>&gt;();</span></code></pre></div>
<p>右辺の不等号で囲われた部分を省略できないようになっています。古いバージョンのJavaでの開発を行う場合は、この点に注意しましょう。</p>
<h1 id="arraylistの使用方法">ArrayListの使用方法</h1>
<h2 id="宣言と確保">宣言と確保</h2>
<p>上で書いたサンプルソースの通りです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1"></a><span class="bu">ArrayList</span>&lt;格納するクラス型&gt; 変数名 = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">// インターフェイスを型とすることで、ArrayList以外のListのオブジェクトも格納できる</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="bu">List</span>&lt;格納するクラス型&gt; 変数名 = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span></code></pre></div>
<h2 id="要素の追加取得削除調査">要素の追加・取得・削除・調査</h2>
<h3 id="要素の追加">要素の追加</h3>
<p>要素を追加するには、<code>add()</code>メソッド、または<code>set()</code>メソッドを使用します。 <code>add()</code> メソッドを単一の引数で指定すると、ArrayListの末尾の要素として <strong><em>追加</em></strong> されます。<br />
また、0〜要素数の最大 - 1のインデックスをintで指定するのと同時に値を引数で指定すれば、インデックスで指定した箇所に挿入することもできます。インデックスは配列と同じく、0から始まる点に注意しましょう。現在の要素数を取得する場合は、<code>size()</code>メソッドで取得できます。配列と同様に、範囲外のインデックスを指定しないように注意しましょう。</p>
<p><code>set()</code>メソッドでは、インデックスと、値の2つの引数を指定します。addと異なり、指定したインデックスの要素を<strong><em>上書き</em></strong>します。</p>
<h3 id="要素の取得">要素の取得</h3>
<p>単一の要素を取得する場合は、<code>get()</code>メソッドを使用します。getメソッドの引数には、リストのインデックスを指定します。指定されたインデックスにある要素を取り出すことができます。</p>
<p>リストの要素を順に取得する場合の書き方は、後ほどまとめます。</p>
<h3 id="要素の削除">要素の削除</h3>
<p>すべての要素を削除する場合は<code>clear()</code>メソッド、指定したインデックスの要素を削除する場合は、<code>remove()</code>メソッドを使用します。removeメソッドで要素の削除を行った場合は、削除された要素分、上に詰められるイメージです。削除された要素以降の要素を指し示すインデックスもそれによって変化する点に注意しましょう。</p>
<h3 id="リストを調査">リストを調査</h3>
<p>上記「要素の追加」でも書きましたが、現在の要素数は、<code>size()</code>メソッドで取得できます。配列などのlengthではないので注意しましょう。 また、要素が空かどうかを調べる場合には、専用のメソッドの<code>isEmpty()</code>メソッドがあります。要素がからかどうかは、<code>size()</code>を使用しないでこちらを使用したほうがコードが読みやすくなります。</p>
<p>リストの中に、要素が存在するかどうかを判断する場合は、<code>contains()</code>メソッドを使用します。「何番目？」まで調べたい場合は、<code>indexOf()</code>を使用するようにしましょう。</p>
<h2 id="リストの要素を順に取得する3つの方法">リストの要素を順に取得する3つの方法</h2>
<h3 id="for文">for文</h3>
<p>バグを発生させやすくなるため、特別な理由がない限りあまり使用しない方が良いです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">//List&lt;String&gt; nameList = new ArrayList&lt;&gt;();</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nameList.<span class="fu">size</span>(); i++) {</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(nameList.<span class="fu">get</span>(i));</span>
<span id="cb6-4"><a href="#cb6-4"></a>}</span></code></pre></div>
<h3 id="拡張for文">拡張for文</h3>
<p>配列の時と同じです。要素を一つずつ取り出し、ループさせます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">//List&lt;String&gt; nameList = new ArrayList&lt;&gt;();</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">for</span> (<span class="bu">String</span> name: nameList) {</span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(name);</span>
<span id="cb7-4"><a href="#cb7-4"></a>}</span></code></pre></div>
<h3 id="イテレータを使用する">イテレータを使用する</h3>
<p>Iteratorと呼ばれる、コレクションに格納された値を順に取り出すための専用の道具を用いる方法です。</p>
<p>用途は限られますが、開発を続ければ必ず必要になります。<br />
理由は、whileループの最中にデータの削除をしたい場合、この方法でないとできません。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">//import java.util.ArrayList;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">//import java.util.Iterator;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; nameList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb8-6"><a href="#cb8-6"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;たろう&quot;</span>);</span>
<span id="cb8-7"><a href="#cb8-7"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;じろう&quot;</span>);</span>
<span id="cb8-8"><a href="#cb8-8"></a>nameList.<span class="fu">add</span>(<span class="st">&quot;さぶろう&quot;</span>);</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">//イテレータの取得</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="bu">Iterator</span>&lt;<span class="bu">String</span>&gt; its = nameList.<span class="fu">iterator</span>();</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">while</span>(its.<span class="fu">hasNext</span>()) {          <span class="co">//次の値があるまで繰り返す</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="bu">String</span> name = its.<span class="fu">next</span>();   <span class="co">//次の値を取得する</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(name);</span>
<span id="cb8-15"><a href="#cb8-15"></a>}</span></code></pre></div>
<h3 id="それぞれのメリットデメリット">それぞれのメリット・デメリット</h3>
<p>以下の表にまとめます。</p>
<table>
<colgroup>
<col style="width: 17%"></col>
<col style="width: 55%"></col>
<col style="width: 26%"></col>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">取り出し方</th>
<th style="text-align: left;">メリット</th>
<th style="text-align: left;">デメリット</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">for文</td>
<td style="text-align: left;">拡張forが実装されていない古いバージョンのJavaでも使用可能</td>
<td style="text-align: left;">構文が複雑でバグを含みやすい</td>
</tr>
<tr class="even">
<td style="text-align: left;">拡張for文</td>
<td style="text-align: left;">構文が単純で、setメソッドなども使用可能</td>
<td style="text-align: left;">Java SE 6以降のみ使用可能</td>
</tr>
<tr class="odd">
<td style="text-align: left;">イテレータ</td>
<td style="text-align: left;">古いバージョンのJavaでも利用可能で、setメソッドなども使用可能<br>また、ループ処理中に、要素の削除が可能という大きなメリットがある</td>
<td style="text-align: left;">構文が若干わかりづらいかも</td>
</tr>
</tbody>
</table>
<p>状況に応じて、使い分けるようにしましょう。</p>
<h2 id="その他のリスト">その他のリスト</h2>
<p>コレクションフレームワークには、ArrayListの他に、<code>LinkedList</code>というリストがあります。</p>
<h3 id="linkedlistとarraylistの違い">LinkedListとArrayListの違い</h3>
<p>基本的な動きはArrayListと同様です。今までのサンプルソースのArrayListをLinkedListに変更しても問題なく動作します。</p>
<p>では、どこが違うかと言うと、内部処理の違いがあります。</p>
<p>膨大なデータを扱う場合には、気をつけるべき点ではありますが、ArrayListは要素の「挿入」や「削除」が苦手です。処理が遅くなる場合があります。これは、ArrayListの内部的なデータの持ち方が、それぞれ整列した状態でメモリ上に展開されているからです。要素の挿入、削除が行われると、メモリ上のデータも整列し直す必要があります。</p>
<p>これに比べ、LinkedListは、各要素がメモリ上にバラバラに配置され、要素一つ一つが次の要素のメモリアドレスと前の要素のメモリアドレスを保持するようになっており、要素の追加、削除をしたとしても、前後の要素が持つ次と前の要素のメモリアドレスを書き換えるだけで良いです。 こういった構造を<code>連結リスト</code>と呼びます。</p>
<p>ArrayListとLinkedListの得手不得手を表にまとめると以下のようになります。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">ArrayList</th>
<th style="text-align: left;">LinkedList</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">内部構造</td>
<td style="text-align: left;">配列（隙間なく順序どおりに並ぶ）</td>
<td style="text-align: left;">連結リスト</td>
</tr>
<tr class="even">
<td style="text-align: left;">要素の挿入・削除</td>
<td style="text-align: left;">遅い（要素数に応じる）</td>
<td style="text-align: left;">高速</td>
</tr>
<tr class="odd">
<td style="text-align: left;">指定位置の要素の取得</td>
<td style="text-align: left;">高速</td>
<td style="text-align: left;">遅い</td>
</tr>
</tbody>
</table>
<p>それぞれ用途に合わせてどちらを使用するか選択しましょう。</p>
<h3 id="どちらもjavautillistインターフェイスを実装している">どちらも<code>java.util.Listインターフェイス</code>を実装している</h3>
<p>そのため、アップキャストが可能です。 単純にListで宣言し、中身はArrayListでもLinkedListでもどちらでも良い、という状態にもできます。普段は、変更に強くするため、こちらの書き方を行います。</p>
<p>例えば、以下のようになります。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; arrayList = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; linkedList = <span class="kw">new</span> <span class="bu">LinkedList</span>&lt;&gt;();</span></code></pre></div>
<h3 id="おまけ配列とarraylistの相互変換">おまけ（配列とArrayListの相互変換）</h3>
<p>配列は、[]などの記号で表していましたが、Javaにはこれらをうまく使うためのクラスが存在します。</p>
<p>それが、<code>java.util.Arrays</code>クラスです。</p>
<p>Arraysクラスには、<code>asList( 配列インスタンス )</code>の静的メソッドを持ちます。これが、配列からListのインスタンスに変換して返す為のメソッドです。</p>
<p>注意点は、asListの戻り値自体は残念ながら<strong><em>固定長のList</em></strong>です。 なので、<code>add()</code>メソッドなどのサイズを変更しうるメソッドの呼び出しはは<code>java.lang.UnsupportedOperationException</code>が発生してしまい使用できません。</p>
<p>そこで以下のソースコードを試して見ましょう</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args[]) {</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="bu">String</span>[] arr={<span class="st">&quot;その１&quot;</span>,<span class="st">&quot;その２&quot;</span>,<span class="st">&quot;その３&quot;</span>};</span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="co">// 配列からArrayListへ変換</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    java.<span class="fu">util</span>.<span class="fu">List</span>&lt;<span class="bu">String</span>&gt; list = <span class="kw">new</span> java.<span class="fu">util</span>.<span class="fu">ArrayList</span>&lt;&gt;();</span>
<span id="cb10-6"><a href="#cb10-6"></a>    list.<span class="fu">addAll</span>(java.<span class="fu">util</span>.<span class="fu">Arrays</span>.<span class="fu">asList</span>(arr));</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="co">// コレクションを拡張forで洗い出し</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">for</span> (<span class="bu">String</span> str : list) {</span>
<span id="cb10-10"><a href="#cb10-10"></a>        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(str);</span>
<span id="cb10-11"><a href="#cb10-11"></a>    }</span>
<span id="cb10-12"><a href="#cb10-12"></a>}</span></code></pre></div>
<p>一旦ArrayListのインスタンスを生成してから、ArrayListに対して<code>addAll</code>メソッドでデータを追加する形式を使用します。 これで配列をArrayListに変換ができました。</p>
<p>また、要素の追加を行わないのであれば、以下のようなList変換でも良いです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1"></a>java.<span class="fu">util</span>.<span class="fu">List</span>&lt;<span class="bu">String</span>&gt; list = java.<span class="fu">util</span>.<span class="fu">Arrays</span>.<span class="fu">asList</span>(arr);</span></code></pre></div>
<p>逆の場合は、Listインターフェイスのインスタンスが持つ<code>toArray</code>メソッドを使うことで可能です。<br />
以下のソースコードを使って下さい。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args[]) {</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</span>
<span id="cb12-3"><a href="#cb12-3"></a>    list.<span class="fu">add</span>(<span class="st">&quot;その１&quot;</span>);</span>
<span id="cb12-4"><a href="#cb12-4"></a>    list.<span class="fu">add</span>(<span class="st">&quot;その２&quot;</span>);</span>
<span id="cb12-5"><a href="#cb12-5"></a>    list.<span class="fu">add</span>(<span class="st">&quot;その３&quot;</span>);</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="co">// ArrayListのtoArrayでStringの配列型を指定して配列へ変換</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="bu">String</span>[] array =(<span class="bu">String</span>[])list.<span class="fu">toArray</span>(<span class="kw">new</span> <span class="bu">String</span>[list.<span class="fu">size</span>()]);</span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="kw">for</span> (<span class="bu">String</span> str : array) {</span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(str);</span>
<span id="cb12-12"><a href="#cb12-12"></a>    }</span>
<span id="cb12-13"><a href="#cb12-13"></a>}</span></code></pre></div>
<p>このように、Listと配列には、相互に変換する仕組みがあるため、配列で用意されたデータであってもListの機能を使うことが可能です。</p>
<h1 id="セットjavautilsetインターフェイスを実装したコレクション">セット(java.util.Setインターフェイスを実装したコレクション)</h1>
<h2 id="setは集合を実現するコレクション">Setは「集合」を実現するコレクション</h2>
<p>Setインターフェイスを実装したコレクションは要素の重複はできませんし、順序関係が基本的にありません。</p>
<p>そのため、要素の順序は気にしないが、重複してもらっては困るようなデータを格納する場合に用いられます。例えば、信号の色をひとまとめに管理したい状況で言えば、「赤」「青」「黃」の3色で、これらが重複することはありません。</p>
<h2 id="listとの違い">Listとの違い</h2>
<h3 id="1-要素の値の重複は無視される">1. 要素の値の重複は無視される</h3>
<p><code>add()</code>メソッドで重複する値を追加しようとした場合は、特にエラーも出ず、追加が無視される仕組みになっています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">//import java.util.Set;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">//import java.util.HashSet;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="bu">Set</span>&lt;<span class="bu">String</span>&gt; shingou = <span class="kw">new</span> <span class="bu">HashSet</span>&lt;&gt;();</span>
<span id="cb13-6"><a href="#cb13-6"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;赤&quot;</span>);</span>
<span id="cb13-7"><a href="#cb13-7"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;青&quot;</span>);</span>
<span id="cb13-8"><a href="#cb13-8"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;黃&quot;</span>);</span>
<span id="cb13-9"><a href="#cb13-9"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;青&quot;</span>);   <span class="co">//青はすでに登録されているので無視されます</span></span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(shingou.<span class="fu">size</span>());    <span class="co">//「3」と表示される</span></span></code></pre></div>
<h3 id="2-setgetがない">2. set(),get()がない</h3>
<p>要素のインデックス自体が存在しないため、インデックスを指定して要素を取得するようなことはできません。</p>
<h3 id="3-順に取り出す場合順序は不明">3. 順に取り出す場合、順序は不明</h3>
<p>addした順に取り出されるわけではありません。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">//import java.util.Set;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">//import java.util.HashSet;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="bu">Set</span>&lt;<span class="bu">String</span>&gt; shingou = <span class="kw">new</span> <span class="bu">HashSet</span>&lt;&gt;();</span>
<span id="cb14-6"><a href="#cb14-6"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;赤&quot;</span>);</span>
<span id="cb14-7"><a href="#cb14-7"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;青&quot;</span>);</span>
<span id="cb14-8"><a href="#cb14-8"></a>shingou.<span class="fu">add</span>(<span class="st">&quot;黃&quot;</span>);</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">for</span> (<span class="bu">String</span> colorName: shingou) {</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(colorName);    <span class="co">//「赤青黃」の順で出てくるとは限らない。</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>}</span></code></pre></div>
<h2 id="setのバリエーション">Setのバリエーション</h2>
<h3 id="hashset">HashSet</h3>
<p>単に集合を表すコレクションで、重複は不可、順序もバラバラ。</p>
<h3 id="linkedhashset">LinkedHashSet</h3>
<p>HashSetに順序を持たせたコレクションで、追加した順に順序ができる。</p>
<h3 id="treeset">TreeSet</h3>
<p>HashSetを<code>自然順序付け</code>で並び替えるコレクション。</p>
<p>自然順序付けとは、例えば、Stringクラスなら辞書順、Integerクラスなら数値の昇順といった具合に並べる順序付けです。独自に作成したクラスの場合は、自然順序付けができない場合があります。注意しましょう。</p>
<h1 id="listとsetとjavautilcollection">ListとSetとjava.util.Collection</h1>
<p>ListとSetは、それぞれのインターフェイスの他に、<code>java.util.Collection</code>を親として持っています。このインターフェイスは、「値が重複しているかどうかに関わらず何らかの単独のデータの集まり」を表現するとても抽象度の高いインターフェイスです。</p>
<p>次に説明するMapは、「Key-Valueのペアデータの集まり」を表現するので、Collectionインターフェイスを親に持ちません。</p>
<h1 id="マップjavautilmapインターフェイスを実装したコレクション">マップ(java.util.Mapインターフェイスを実装したコレクション)</h1>
<h2 id="mapはkey-valueでのペアを格納するデータ構造">MapはKey-Valueでのペアを格納するデータ構造</h2>
<p>Mapは、キーとなる値をインデックスの代わりに用いるコレクションです。<br />
ListやSetと違い、Mapではジェネリクスで指定する型はKeyとValueでそれぞれ1つずつ必要です。</p>
<h3 id="インスタンス化">インスタンス化</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">Map</span>&lt;キーとなるクラス型, 値となるクラス型&gt; 変数名 = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</span></code></pre></div>
<h3 id="要素の追加-1">要素の追加</h3>
<p>要素の追加は、addではなく<code>put()</code>メソッドを用います。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">//import java.util.Map;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">//import java.util.HashMap;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt; telMap = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</span>
<span id="cb16-6"><a href="#cb16-6"></a>map.<span class="fu">put</span>(<span class="st">&quot;東京&quot;</span>, <span class="st">&quot;03&quot;</span>);</span>
<span id="cb16-7"><a href="#cb16-7"></a>map.<span class="fu">put</span>(<span class="st">&quot;名古屋&quot;</span>, <span class="st">&quot;052&quot;</span>);</span></code></pre></div>
<p>注意点として、Mapは、値の重複は可能ですが、キーの重複はできません。 キーが重複する要素を追加した場合は、値ごと要素が上書きされてしまうので注意しましょう。</p>
<h3 id="要素の削除-1">要素の削除</h3>
<p>要素の削除は、<code>remove()</code>メソッドでキーのみ指定します。</p>
<h3 id="mapの調査">Mapの調査</h3>
<p>要素が空である場合は、<code>isEmpty()</code>、指定したキーの要素が含まれているかは<code>containsKey()</code>でキーを指定する、指定した値の要素が含まれているかは<code>containsValue()</code>で値を指定する。といった具合でできます。</p>
<h3 id="mapの要素を一つずつ取り出す">Mapの要素を一つずつ取り出す</h3>
<p>まずは以下のような拡張forの書き方はできません。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="co">//import java.util.Map;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="co">//import java.util.HashMap;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt; telMap = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</span>
<span id="cb17-6"><a href="#cb17-6"></a>telMap.<span class="fu">put</span>(<span class="st">&quot;東京&quot;</span>, <span class="st">&quot;03&quot;</span>);</span>
<span id="cb17-7"><a href="#cb17-7"></a>telMap.<span class="fu">put</span>(<span class="st">&quot;名古屋&quot;</span>, <span class="st">&quot;052&quot;</span>);</span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="kw">for</span> (<span class="bu">String</span> tel: telMap) {  <span class="co">//コンパイルエラーになります。</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>}</span></code></pre></div>
<p>では、どうやって拡張forを使用するかというと、少し工夫が必要です。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">//インポートが必要です。</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="co">//import java.util.Map;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co">//import java.util.HashMap;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt; telMap = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</span>
<span id="cb18-6"><a href="#cb18-6"></a>telMap.<span class="fu">put</span>(<span class="st">&quot;東京&quot;</span>, <span class="st">&quot;03&quot;</span>);</span>
<span id="cb18-7"><a href="#cb18-7"></a>telMap.<span class="fu">put</span>(<span class="st">&quot;名古屋&quot;</span>, <span class="st">&quot;052&quot;</span>);</span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="kw">for</span> (<span class="bu">String</span> key: telMap.<span class="fu">keySet</span>()) {  <span class="co">//マップが持つキーのセットを取得して回す</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="bu">String</span> value = telMap.<span class="fu">get</span>(key); <span class="co">//回ってきたキーで値を取得</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;キー：&quot;</span> + key + <span class="st">&quot; 値：&quot;</span> + value);</span>
<span id="cb18-12"><a href="#cb18-12"></a>}</span></code></pre></div>
<p>まずは、Mapは、キーのSetを持っていて、<code>keySet()</code>メソッドで取得することができます。これを拡張forに使用すれば良いです。</p>
<p>また、HashMapは、HashSetと同様に、順序を保証しません。 格納した順番に出力されるとは限らないので、順序を指定したい場合は、Setと同様に、LinkedHashMapおよび、TreeMapを使用しましょう。</p>
<h1 id="まとめ">まとめ</h1>
<ul>
<li>コレクションには、List,Set,Mapの3種類がある。
<ul>
<li>重複を許可し、順序をもたせるならList</li>
<li>重複を許可せず、順序がなくても良い場合はSet</li>
<li>インデックスに数値以外を使用したい、もしくは、インデックスに意味を持たせたい場合はMap</li>
</ul></li>
<li>利用すべきコレクションを選ぶには以下のようにする。
<ul>
<li>格納したいデータは……
<ul>
<li>ペアの集まり
<ul>
<li>取り出す順序
<ul>
<li>不問 : HashMap</li>
<li>格納順 : LinkedHashMap</li>
<li>自然順序 : TreeMap</li>
</ul></li>
</ul></li>
</ul></li>
<li>データの重複は……
<ul>
<li>あり得ない
<ul>
<li>取り出す順序
<ul>
<li>不問 : HashSet</li>
<li>格納順 : LinkedHashSet</li>
<li>自然順序 : TreeSet</li>
</ul></li>
</ul></li>
</ul></li>
<li>要素の追加・挿入・削除は……
<ul>
<li>多くない
<ul>
<li>インデックス指定での要素取得は……
<ul>
<li>多い
<ul>
<li>ArrayList</li>
</ul></li>
<li>多くない
<ul>
<li>ArrayListかLinkedArrayListどちらでもよい</li>
</ul></li>
</ul></li>
</ul></li>
<li>多い
<ul>
<li>インデックス指定での要素取得は……
<ul>
<li>多い
<ul>
<li>ArrayListかLinkedArrayListどちらでもよい</li>
</ul></li>
<li>多くない
<ul>
<li>LinkedArrayList</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</body>
</html>